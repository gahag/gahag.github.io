<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- Apr 07, 2021 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Custom syntax highlighter for LaTeX</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Gahag" />
<link rel='icon' type='image/png' href='/images/favicon.png'/>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<link rel='preconnect' href='https://fonts.gstatic.com'>
<link href='https://fonts.googleapis.com/css2?family=Zilla+Slab:wght@300&display=swap' rel='stylesheet'>
<link rel='stylesheet' href='/css/site.css?v=2' type='text/css'/>
<link rel='stylesheet' href='/css/custom.css' type='text/css'/>
<link rel='stylesheet' href='/css/syntax-coloring.css' type='text/css'/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/"> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><header id="top" class="status">
<div class='intro'>
	<img src='/images/about/profile.png' alt='gahag' class='no-border'/>
	<h1>
		<span class="black">Gahag's Blog</span>
	</h1>
</div>

<div class='nav'>
	<ul>
		<li><a href='/'>Home</a> -</li>
		<li><a href='http://github.com/gahag'>Github</a> -</li>
		<li><a href='/about/'>About</a></li>
	</ul>
</div>
</header>
<main id="content">
<h1 class="title">Custom syntax highlighter for LaTeX
<br />
<span class="subtitle">Published on Apr 02, 2021 by Gahag.</span>
</h1>
<p>
LaTeX has great syntax highlight support for code with the Minted<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
package. Minted uses Pygments<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> as tokenizer, and it supports a long list of
programming languages<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>. But what if we want to use a programming
language that is not supported by Pygments, perhaps one that we&rsquo;re designing?
</p>

<p>
In this post, I&rsquo;ll show how to make a custom lexer for Pygments, which will allow syntax
highlighting through Minted. In particular, this should also work out of the box with
anything that produces LaTeX, including Emacs&rsquo; Org-mode<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>.
</p>

<p>
Let&rsquo;s create a custom lexer for Hush<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>, a programming language that I&rsquo;m working
on. First, let&rsquo;s create the following directory structure for our custom lexer:
</p>
<pre class="example">
.
├── lexer
│   ├── hush.py
│   └── __init__.py
└── setup.py
</pre>

<ul class="org-ul">
<li>The <code>hush.py</code> file will contain our lexer implementation.</li>
<li>The <code>__init__.py</code> file may be left empty.</li>
<li>The <code>setup.py</code> file will contain the setup for our package, including integration with
the system Pygments installation.</li>
</ul>

<p>
Pygments implements lexing based on regular expressions. Therefore, we must construct our
custom lexer by using regular expressions for each kind of token, and connect those using
Pygments&rsquo; facilities.
</p>

<p>
In the <code>hush.py</code> file, we define our implementation (you may want to replace <i>hush</i> with your
language name):
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> pygments.lexer <span class="org-keyword">import</span> RegexLexer, include, default, combined
<span class="org-keyword">from</span> pygments.token <span class="org-keyword">import</span> Text, Comment, Operator, Keyword, Name, \
  String, Number, Punctuation


<span class="org-keyword">class</span> <span class="org-type">HushLexer</span>(RegexLexer):
  <span class="org-doc">"""</span>
<span class="org-doc">  For Hush scripts.</span>
<span class="org-doc">  """</span>

  <span class="org-variable-name">name</span> = <span class="org-string">'Hush'</span>
  <span class="org-variable-name">aliases</span> = [<span class="org-string">'hush'</span>]
  <span class="org-variable-name">filenames</span> = [<span class="org-string">'*.hsh'</span>]
  <span class="org-variable-name">mimetypes</span> = [<span class="org-string">'text/x-hush'</span>, <span class="org-string">'application/x-hush'</span>]

  <span class="org-comment-delimiter"># </span><span class="org-comment">Here are the syntax definitions for our language:</span>
  <span class="org-variable-name">tokens</span> = {
    <span class="org-string">'root'</span>: [
      <span class="org-comment-delimiter"># </span><span class="org-comment">Hush allows a file to start with a shebang.</span>
      (r<span class="org-string">'#!.*'</span>, Comment.Preproc),
      default(<span class="org-string">'base'</span>),
    ],
    <span class="org-string">'ws'</span>: [ <span class="org-comment-delimiter"># </span><span class="org-comment">Whitespace</span>
      (r<span class="org-string">'(?:#.*$)'</span>, Comment.Single), <span class="org-comment-delimiter"># </span><span class="org-comment">Comments start with '#'.</span>
      (r<span class="org-string">'(?:\s+)'</span>, Text),
    ],
    <span class="org-string">'base'</span>: [
      include(<span class="org-string">'ws'</span>),

       <span class="org-comment-delimiter"># </span><span class="org-comment">Hex numbers:</span>
      (r<span class="org-string">'(?i)0x[\da-f]*(\.[\da-f]*)?(p[+-]?\d+)?'</span>, Number.Hex),
      <span class="org-comment-delimiter"># </span><span class="org-comment">Floats, including exponent notation:</span>
      (r<span class="org-string">'(?i)(\d*\.\d+|\d+\.\d*)(e[+-]?\d+)?'</span>, Number.Float),
      (r<span class="org-string">'(?i)\d+e[+-]?\d+'</span>, Number.Float),
      <span class="org-comment-delimiter"># </span><span class="org-comment">Integers:</span>
      (r<span class="org-string">'\d+'</span>, Number.Integer),

      (r<span class="org-string">'[\?\$!=&lt;&gt;{}|+\-*/%]+'</span>, Operator), <span class="org-comment-delimiter"># </span><span class="org-comment">List of operators.</span>
      (r<span class="org-string">'[\[\]().,:;]|@\['</span>, Punctuation),  <span class="org-comment-delimiter"># </span><span class="org-comment">Other punctuation.</span>
      (r<span class="org-string">'(and|or|not)\b'</span>, Operator.Word),  <span class="org-comment-delimiter"># </span><span class="org-comment">Non-symbol operators.</span>

      <span class="org-comment-delimiter"># </span><span class="org-comment">Keywords:</span>
      (r<span class="org-string">'(if|then|else|end|for|in|return)\b'</span>, Keyword.Reserved),
      <span class="org-comment-delimiter"># </span><span class="org-comment">Some keyword classes can be used:</span>
      (r<span class="org-string">'(let)\b'</span>, Keyword.Declaration),
      (r<span class="org-string">'(true|false|nil)\b'</span>, Keyword.Constant),
      <span class="org-comment-delimiter"># </span><span class="org-comment">Here, we indicate that the 'funcname' rule should be used</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">whenever the 'function' keyword is found:</span>
      (r<span class="org-string">'(function)\b'</span>, Keyword.Reserved, <span class="org-string">'funcname'</span>),

      <span class="org-comment-delimiter"># </span><span class="org-comment">Identifiers:</span>
      (r<span class="org-string">'[A-Za-z_]\w*(\.[A-Za-z_]\w*)?'</span>, Name),

      <span class="org-comment-delimiter"># </span><span class="org-comment">Strings:</span>
      (<span class="org-string">'"'</span>, String.Double, combined(<span class="org-string">'stringescape'</span>, <span class="org-string">'string'</span>))
    ],

    <span class="org-string">'funcname'</span>: [ <span class="org-comment-delimiter"># </span><span class="org-comment">Function names.</span>
      include(<span class="org-string">'ws'</span>),
      (r<span class="org-string">'(?:[^\W\d]\w*)'</span>, Name.Function, <span class="org-string">'#pop'</span>),
      <span class="org-comment-delimiter"># </span><span class="org-comment">inline function</span>
      (r<span class="org-string">'\('</span>, Punctuation, <span class="org-string">'#pop'</span>),
    ],

    <span class="org-string">'stringescape'</span>: [ <span class="org-comment-delimiter"># </span><span class="org-comment">Escaped characters inside strings.</span>
      (
        r<span class="org-string">'\\([abfnrtv\\"\']'</span>
        r<span class="org-string">'|[\r\n]{1,2}'</span>
        r<span class="org-string">'|z\s*'</span>
        r<span class="org-string">'|x[0-9a-fA-F]{2}'</span>
        r<span class="org-string">'|\d{1,3}'</span>
        r<span class="org-string">'|u\{[0-9a-fA-F]+\})'</span>,
        String.Escape
      ),
    ],

    <span class="org-string">'string'</span>: [ <span class="org-comment-delimiter"># </span><span class="org-comment">Strings.</span>
      (r<span class="org-string">'"'</span>, String.Double, <span class="org-string">'#pop'</span>),
      (r<span class="org-string">'[^\\"]+'</span>, String.Double),
    ]
  }

  <span class="org-comment-delimiter"># </span><span class="org-comment">We can override this function to manually parse subexpressions. In</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">this case, we're splitting dotted names, so that the dot itself</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">won't be highlighted as a name.</span>
  <span class="org-keyword">def</span> <span class="org-function-name">get_tokens_unprocessed</span>(<span class="org-keyword">self</span>, text):
    <span class="org-keyword">for</span> index, token, value <span class="org-keyword">in</span> RegexLexer.get_tokens_unprocessed(<span class="org-keyword">self</span>, text):
      <span class="org-keyword">if</span> token <span class="org-keyword">is</span> Name <span class="org-keyword">and</span> <span class="org-string">'.'</span> <span class="org-keyword">in</span> value:
        <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> = value.split(<span class="org-string">'.'</span>)
        <span class="org-keyword">yield</span> index, Name, a
        <span class="org-keyword">yield</span> index + <span class="org-builtin">len</span>(a), Punctuation, <span class="org-string">'.'</span>
        <span class="org-keyword">yield</span> index + <span class="org-builtin">len</span>(a) + 1, Name, b
        <span class="org-keyword">continue</span>
      <span class="org-keyword">yield</span> index, token, value
</pre>
</div>

<p>
Insert the following contents for <code>setup.py</code> (you may want to replace <i>hush</i> with your
language name):
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> setuptools <span class="org-keyword">import</span> setup, find_packages

setup(
  name=<span class="org-string">'hushlexer'</span>,
  packages=find_packages(),
  entry_points =
  <span class="org-string">'''</span>
<span class="org-string">  [pygments.lexers]</span>
<span class="org-string">  hushlexer = lexer.hush:HushLexer</span>
<span class="org-string">  '''</span>,
)
</pre>
</div>

<p>
Finally, from the project root, run the installation command:
</p>
<div class="org-src-container">
<pre class="src src-bash">$ python setup.py install --user
</pre>
</div>

<p>
Pygments should then recognize your lexer automatically. Therefore, source code blocks
using pygments should work out of the box. Here&rsquo;s an example of how it looks like for
Hush:
</p>


<div class="figure">
<p><img src="../images/posts/Custom syntax highlighter for LaTeX/hush-syntax-highlight.png" alt="hush-syntax-highlight.png" />
</p>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted">https://www.overleaf.com/learn/latex/Code_Highlighting_with_minted</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://pygments.org/">https://pygments.org/</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<a href="https://pygments.org/languages/">https://pygments.org/languages/</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
<a href="https://orgmode.org/">https://orgmode.org/</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
<a href="https://github.com/gahag/hush">https://github.com/gahag/hush</a>
</p></div></div>


</div>
</div></main>
<footer id="postamble" class="status">
<div class='footer'>
  Copyright © 2021 <a href='mailto:gabriel.s.b@live.com'>Gabriel Bastos</a>.<br>
  Template by <a href='https://gitlab.com/psachin/psachin.gitlab.io/'>Sachin Patil</a> <br>
  Last updated on Apr 07, 2021. Generated using <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.1.9).
</div>
</footer>
</body>
</html>
